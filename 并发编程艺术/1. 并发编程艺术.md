# 并发编程艺术 {ignore}
[toc]

## 第一章 并发编程的挑战

### 1.1 上下文的切换

即使单核处理器支持多线程执行代码，CPU通过给每一个线程分配CPU时间片（几十ms）段来实现多线程的机制。来回切换线程（保存和加载过程）会有开销。

### 1.2 死锁
定义：两个或多个线程同时等待对方释放锁时，会产生死锁。
避免方法：
- 避免一个线程同时获得多个锁。
- 避免一个线程在锁内同时占用多个资源，尽量保证一个锁只占用一个资源。
- 使用定时锁，lock.tryLock(timeout)。
- 对数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。

### 1.3 资源限制

## 第二章 java并发机制的底层实现原理
java代码编译后会变成字节码，字节码被类加载器加载到JVM里，JVM执行字节码最终转化为汇编在CPU上执行。

### 2.1 volatile的应用

1. colatile的定义与实现原理
- 定义：如果一个变量被声明为volatile,所有线程看到这个变量的只是一致的。

CPU的术语定义
![](images/2019-09-03-21-12-51.png)

- 实现原理：
在对声明了volatile变量进行读写操作时，JVM会向处理器发送一条Lock前缀指令，Lock前缀指令的作用：
（1）Lock前缀指令会引起处理器将缓存写到内存中。
（2）一个处理器的缓存写到内存会导致其他处理器的缓存无效。

2. volatile 的使用优化
**一个对象引用占四个字节**
追加64个字节能够提高并发效率，因为追加64个字节使得队列的头和尾不在同一个高速缓存行内，修改头或尾时只会锁定整个缓冲行，从而使得一个队列的头和尾可以同时被访问修改。

### 2.2 synchronized的实现原理
**重量级锁**
- synchronized实现同步的基础：java中的每一个对象都可以作为锁。
    - 对于普通同步方法，锁时当前**实例对象**
    - 对于静态同步方法，锁是当前类的**class对象**
    - 对于同步方法块，锁是**Sychronized括号里面配置的对象**
    当以一个线程访问同步代码块时，他首先需要获得锁，退出或抛出异常时必须释放锁。

JVM基于进入和退出Monitor对象来实现方法同步和代码块同步。但实现细节不一样，代码块同步是使用monitorenter和monitorexit指令来实现。
monitorenter指令在编译后插入到同步代码块开始位置，而monitorexit指令插入到方法借宿和异常出，jvm要保证每一个monitorenter必须有一个对应的monitorexit与之配对。任何一个对象都有一个monitor与之关联，当一个monitor被持后，它将处与锁定状态。线程执行到monitorenter指令时，将会尝试获取对应monitor的所有权，即尝试获得对象的锁。

&emsp;&emsp;**总结：sychronized关键字会使得代码在编译后将插入monitorenter和monitorexit指令。每一个对象都有与之关联的monitor对象，当线程执行到monitorenter指令时，将会尝试获取monitor的所有权，即获得锁，执行到monitorexit时，将会释放锁。monitorenter与monitorexit成对存在。**

2.2.1 Java对象头
&emsp;&emsp;sychronized用的锁是存在Java对象头里面的。
数组对象头：3个字宽存储对象头 32位虚拟机一个字宽4个字节。
非数组对象：2个字宽存储对象头 64位虚拟机一个字宽8个字节

2.2.2 锁的升级
为减小获得锁和释放锁带来的性能消耗，1.6以后引入偏向锁和轻量级锁。
锁的级别：无锁状态$\longrightarrow$偏向锁状态$\longrightarrow$轻量级锁状态$\longrightarrow$重量级锁状态。
**随竞争激烈程度提升，但只能升级，不能降级**
1. 偏向锁
当一个线程来访问锁时，会在头对象和栈帧中的所记录里存储锁偏向的线程ID，以后该线程在进入和退出同步代码块时不需要尽进行Compare and Swap（CAS）操作来加锁解锁。只需测试对象头中的MARk Word里是否存储着指向当前线程的线程锁。如果测试成功，则表示该线程已经获得锁，如果测试失败，则测试Mark Word中的偏向锁标识是否设置为1，若果没有，则使用CAS竞争锁，如果设置了，则尝试使用CAS将对象头指向该线程。
-偏向锁的撤销