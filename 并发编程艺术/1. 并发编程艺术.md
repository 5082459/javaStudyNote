# 并发编程艺术 {ignore}
[toc]

## 第一章 并发编程的挑战

### 1.1 上下文的切换

即使单核处理器支持多线程执行代码，CPU通过给每一个线程分配CPU时间片（几十ms）段来实现多线程的机制。来回切换线程（保存和加载过程）会有开销。

### 1.2 死锁
定义：两个或多个线程同时等待对方释放锁时，会产生死锁。
避免方法：
- 避免一个线程同时获得多个锁。
- 避免一个线程在锁内同时占用多个资源，尽量保证一个锁只占用一个资源。
- 使用定时锁，lock.tryLock(timeout)。
- 对数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。

### 1.3 资源限制

## 第二章 java并发机制的底层实现原理
java代码编译后会变成字节码，字节码被类加载器加载到JVM里，JVM执行字节码最终转化为汇编在CPU上执行。

### 2.1 volatile的应用

1. colatile的定义与实现原理
- 定义：如果一个变量被声明为volatile,所有线程看到这个变量的只是一致的。

CPU的术语定义
![](images/2019-09-03-21-12-51.png)

- 实现原理：
在对声明了volatile变量进行读写操作时，JVM会向处理器发送一条Lock前缀指令，Lock前缀指令的作用：
（1）Lock前缀指令会引起处理器将缓存写到内存中。
（2）一个处理器的缓存写到内存会导致其他处理器的缓存无效。

2. volatile 的使用优化
**一个对象引用占四个字节**
追加64个字节能够提高并发效率，因为追加64个字节使得队列的头和尾不在同一个高速缓存行内，修改头或尾时只会锁定整个缓冲行，从而使得一个队列的头和尾可以同时被访问修改。

### 2.2 synchronized的实现原理
**重量级锁**
- synchronized实现同步的基础：java中的每一个对象都可以作为锁。
    - 对于普通同步方法，锁时当前**实例对象**
    - 对于静态同步方法，锁是当前类的**class对象**
    - 对于同步方法块，锁是**Sychronized括号里面配置的对象**
    当以一个线程访问同步代码块时，他首先需要获得锁，退出或抛出异常时必须释放锁。

JVM基于进入和退出Monitor对象来实现方法同步和代码块同步。但实现细节不一样，代码块同步是使用monitorenter和monitorexit指令来实现。
monitorenter指令在编译后插入到同步代码块开始位置，而monitorexit指令插入到方法借宿和异常出，jvm要保证每一个monitorenter必须有一个对应的monitorexit与之配对。任何一个对象都有一个monitor与之关联，当一个monitor被持后，它将处与锁定状态。线程执行到monitorenter指令时，将会尝试获取对应monitor的所有权，即尝试获得对象的锁。

&emsp;&emsp;**总结：sychronized关键字会使得代码在编译后将插入monitorenter和monitorexit指令。每一个对象都有与之关联的monitor对象，当线程执行到monitorenter指令时，将会尝试获取monitor的所有权，即获得锁，执行到monitorexit时，将会释放锁。monitorenter与monitorexit成对存在。**

2.2.1 Java对象头
&emsp;&emsp;sychronized用的锁是存在Java对象头里面的。
数组对象头：3个字宽存储对象头 32位虚拟机一个字宽4个字节。
非数组对象：2个字宽存储对象头 64位虚拟机一个字宽8个字节

2.2.2 锁的升级
为减小获得锁和释放锁带来的性能消耗，1.6以后引入偏向锁和轻量级锁。
锁的级别：无锁状态$\longrightarrow$偏向锁状态$\longrightarrow$轻量级锁状态$\longrightarrow$重量级锁状态。
**随竞争激烈程度提升，但只能升级，不能降级**
1. 偏向锁
当一个线程来访问锁时，会在头对象和栈帧中的所记录里存储锁偏向的线程ID，以后该线程在进入和退出同步代码块时不需要尽进行Compare and Swap（CAS）操作来加锁解锁。只需测试对象头中的MARk Word里是否存储着指向当前线程的线程锁。如果测试成功，则表示该线程已经获得锁，如果测试失败，则测试Mark Word中的偏向锁标识是否设置为1，若果没有，则使用CAS竞争锁，如果设置了，则尝试使用CAS将对象头指向该线程。
-偏向锁的撤销
当有其他线程尝试竞争锁的时候偏向锁的持有线程才会释放锁，偏向锁的撤销需要在全局安全点（没有字节码执行）时间上才能进行。
2. 轻量级锁
- 轻量级加锁：
在线程在执行同步代码块之前，JVM会现在当前线程的栈帧中创建用于存储所记录的空间，并且将对象头中的MArk Word复制到锁记录中。然后线程尝试使用将CAS将对象头中的Mar看word替换成指向锁记录的指针。若果成功，当前线程获得锁，否则表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。
**每一个访问同步代码块的线程，将对象头中的Mark Word复制到线程的Display Mark word 中，成功则获得锁，否则自选取锁。**
- 轻量级解锁：
轻量级解锁时，会使原子的CAS操作将会Display Mark Word替换回到对象头Mark Word，若果成功，则表示没有竞争发生。若果失败，则表示当前锁存在竞争，锁就会膨胀成重量级锁。
**当某个线程执行完同步体后，会将Display Mark Word替换到对象头的Mark Word，若果没有线程竞争，则直接替换成功，否则替换失败，升级为重量级锁**

锁的优缺点：
锁|优点|缺点|适应场景
:-:|:-:|:-:|:-:
偏向锁|加锁解锁不需要额外消耗，执行同步代码块和非同步代码块相比仅存在纳秒级差别|若果出现锁的竞争，会带来额外撤销消耗|单线程访问同步代码块场景
轻量级锁|竞争时线程不会阻塞，提高程序的相应速度|若果始终无法获取锁则会消耗CPU资源|追求响应时间同步代码块执行速度非常快
重量级锁|竞争线程不适用自旋，不会消耗CPU|线程阻塞，相应时间缓慢|追求吞吐量，同步代码块执行速度较慢

### 2.3 原子操作的实现原理
原子操作：不可中断的一个或一系列操作
1. 术语定义

术语名称|解释
:-:|:-:
缓存行|缓存的最小操作单位
比较和交换|CAS操作，比较新旧数值是否有变化，有则发生交换
CPU流水线|指令处理流水线，一个CPU时钟内完成一条指令
内存顺序冲突|一般由假共享引起，假共享是指多个CPU同时修改同一缓存行的不同部位而引起其中一个CPU的操作无效，当出现内存顺序冲突时，CPU必须清空流水线

2. 处理器如何实现原子操作
32位IA-32处理器使用基于对**缓存加锁**和**总线加锁**的方式来实现多处理器之间的原子操作。
- 总线加锁：当一个线程处理一个变量时，会在总线上释放一个lock信号，当其他处理器请求访问内存时会被阻塞，实现独占共享资源。（**大家都别取数据**）
- 缓存锁定：锁定缓存行，执行完操作时修改内部的内存地址，并使用缓存一致性时其他CPU缓存无效。

CAS实现原子操作的三大问题
(1) ABA问题，解决：在变量前追加版本号
(2) 循环时间长，开销大。如果自旋CAS长时间不成功，会给CPU带来非常大的执行开销。解决：使用pause指令延时流水线，避免在退出循环因内存冲突引起CPU流水线被清空
(3) 只能保证一个共享变量的原子操作

## 第三章