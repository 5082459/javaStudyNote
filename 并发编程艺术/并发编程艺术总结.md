# 并发编程艺术总结 {ignore}
[toc]

## 第一章
- 上下文切换消耗资源
- 死锁：两个或多个线程等待对方释放锁
- 解决：
    1. 避免同一线程获取多个锁
    2. 避免同一锁占用多个资源
    3. 使用定时锁,lock.tryLock(timeout);

## 第二章
- volatile 变量，线程同步。
- 实现：跟新即刷新缓存（lock命令将缓存写到内存）
- 追加64个字节，提高并发率

- synchronized 
- 使用编译后插入monitorenter（执行到此尝试获取锁）和monitorexit对到同步代码块实现同步。
- 锁可以升级，无偏轻重。
- CAS操作，比较新旧数值是否有变化，有则发生交换

## 第三章
- 每一个线程都有自己的本地内存存放共享变量
- 重排序：**编译器**和**处理器**为**优化程序**对指令进行**重排序**。
- 顺序一致性：所有线程看到的程序顺序都是固定的。
- lock指令执行时会锁住总线
- 禁止该指令与之前和之后的续写指令进行重排序

## 第四章
- 为什么使用多线程：
1. 更多的处理核心
2. 更快的响应时间
3. 更好的编程模型
- setPriority(int )方法来修改优先级，[1,10]
- 线程状态：new ,runnable,blocked,waiting,time_waiting,terminatted.
- volatile：告知程序，在任何时候该变量都要从共享空间中获取，改变则必须刷新。
- synchronized：可以修饰方法或者代码块。只能有一个线程处于同步块中，保证了线程访问变量的的可见性和排他性。获取对象的monitor才能进入同步代码块，否则阻塞。
- wait()方法后，线程进入等待序列，放弃锁。
- notify()将一个等待线程从等待序列移动到同步序列,notifyAll()
- 管道输入输出流用于线程之间的数据传输
- 线程A执行了thread.join()方法，则当前线程A等待thread线程终止以后才从thread.join()返回。
- B线程执行 A.join()，则B线程要等A线程执行完毕才执行。

## 第五章
