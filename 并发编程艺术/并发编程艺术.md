# 并发编程艺术 {ignore}
[toc]

## 第一章 并发编程的挑战

### 1.1 上下文的切换

即使单核处理器支持多线程执行代码，CPU通过给每一个线程分配CPU时间片（几十ms）段来实现多线程的机制。来回切换线程（保存和加载过程）会有开销。

### 1.2 死锁
定义：两个或多个线程同时等待对方释放锁时，会产生死锁。
避免方法：
- 避免一个线程同时获得多个锁。
- 避免一个线程在锁内同时占用多个资源，尽量保证一个锁只占用一个资源。
- 使用定时锁，lock.tryLock(timeout)。
- 对数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。

### 1.3 资源限制

## 第二章 java并发机制的底层实现原理
java代码编译后会变成字节码，字节码被类加载器加载到JVM里，JVM执行字节码最终转化为汇编在CPU上执行。

### 2.1 volatile的应用

1. colatile的定义与实现原理
- 定义：如果一个变量被声明为volatile,所有线程看到这个变量的只是一致的。

CPU的术语定义
![](images/2019-09-03-21-12-51.png)

- 实现原理：
在对声明了volatile变量进行读写操作时，JVM会向处理器发送一条Lock前缀指令，Lock前缀指令的作用：
（1）Lock前缀指令会引起处理器将缓存写到内存中。
（2）一个处理器的缓存写到内存会导致其他处理器的缓存无效。

2. volatile 的使用优化
**一个对象引用占四个字节**
追加64个字节能够提高并发效率，因为追加64个字节使得队列的头和尾不在同一个高速缓存行内，修改头或尾时只会锁定整个缓冲行，从而使得一个队列的头和尾可以同时被访问修改。

### 2.2 synchronized的实现原理
**重量级锁**
- synchronized实现同步的基础：java中的每一个对象都可以作为锁。
    - 对于普通同步方法，锁时当前示例对象
    - 对于静态同步方法，所示当前类的class对象
    - 对于同步方法块，锁时Sychronized括号里面配置的对象
当以一个线程访问同步代码块时，他首先需要获得锁，退出或抛出异常时必须释放锁。